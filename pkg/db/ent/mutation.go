// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/NpoolPlatform/miningpool-middleware/pkg/db/ent/apppool"
	"github.com/NpoolPlatform/miningpool-middleware/pkg/db/ent/coin"
	"github.com/NpoolPlatform/miningpool-middleware/pkg/db/ent/fraction"
	"github.com/NpoolPlatform/miningpool-middleware/pkg/db/ent/fractionrule"
	"github.com/NpoolPlatform/miningpool-middleware/pkg/db/ent/gooduser"
	"github.com/NpoolPlatform/miningpool-middleware/pkg/db/ent/orderuser"
	"github.com/NpoolPlatform/miningpool-middleware/pkg/db/ent/pool"
	"github.com/NpoolPlatform/miningpool-middleware/pkg/db/ent/predicate"
	"github.com/NpoolPlatform/miningpool-middleware/pkg/db/ent/rootuser"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAppPool      = "AppPool"
	TypeCoin         = "Coin"
	TypeFraction     = "Fraction"
	TypeFractionRule = "FractionRule"
	TypeGoodUser     = "GoodUser"
	TypeOrderUser    = "OrderUser"
	TypePool         = "Pool"
	TypeRootUser     = "RootUser"
)

// AppPoolMutation represents an operation that mutates the AppPool nodes in the graph.
type AppPoolMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *uint32
	addcreated_at *int32
	updated_at    *uint32
	addupdated_at *int32
	deleted_at    *uint32
	adddeleted_at *int32
	ent_id        *uuid.UUID
	app_id        *uuid.UUID
	pool_id       *uuid.UUID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppPool, error)
	predicates    []predicate.AppPool
}

var _ ent.Mutation = (*AppPoolMutation)(nil)

// apppoolOption allows management of the mutation configuration using functional options.
type apppoolOption func(*AppPoolMutation)

// newAppPoolMutation creates new mutation for the AppPool entity.
func newAppPoolMutation(c config, op Op, opts ...apppoolOption) *AppPoolMutation {
	m := &AppPoolMutation{
		config:        c,
		op:            op,
		typ:           TypeAppPool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppPoolID sets the ID field of the mutation.
func withAppPoolID(id uint32) apppoolOption {
	return func(m *AppPoolMutation) {
		var (
			err   error
			once  sync.Once
			value *AppPool
		)
		m.oldValue = func(ctx context.Context) (*AppPool, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppPool.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppPool sets the old AppPool of the mutation.
func withAppPool(node *AppPool) apppoolOption {
	return func(m *AppPoolMutation) {
		m.oldValue = func(context.Context) (*AppPool, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppPoolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppPoolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppPool entities.
func (m *AppPoolMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppPoolMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppPoolMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppPool.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppPoolMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppPoolMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppPool entity.
// If the AppPool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPoolMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *AppPoolMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *AppPoolMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppPoolMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppPoolMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppPoolMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppPool entity.
// If the AppPool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPoolMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *AppPoolMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *AppPoolMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppPoolMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AppPoolMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AppPoolMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AppPool entity.
// If the AppPool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPoolMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *AppPoolMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *AppPoolMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AppPoolMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *AppPoolMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *AppPoolMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the AppPool entity.
// If the AppPool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPoolMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *AppPoolMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AppPoolMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppPoolMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppPool entity.
// If the AppPool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPoolMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppPoolMutation) ResetAppID() {
	m.app_id = nil
}

// SetPoolID sets the "pool_id" field.
func (m *AppPoolMutation) SetPoolID(u uuid.UUID) {
	m.pool_id = &u
}

// PoolID returns the value of the "pool_id" field in the mutation.
func (m *AppPoolMutation) PoolID() (r uuid.UUID, exists bool) {
	v := m.pool_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPoolID returns the old "pool_id" field's value of the AppPool entity.
// If the AppPool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPoolMutation) OldPoolID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoolID: %w", err)
	}
	return oldValue.PoolID, nil
}

// ResetPoolID resets all changes to the "pool_id" field.
func (m *AppPoolMutation) ResetPoolID() {
	m.pool_id = nil
}

// Where appends a list predicates to the AppPoolMutation builder.
func (m *AppPoolMutation) Where(ps ...predicate.AppPool) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppPoolMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppPool).
func (m *AppPoolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppPoolMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, apppool.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apppool.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, apppool.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, apppool.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, apppool.FieldAppID)
	}
	if m.pool_id != nil {
		fields = append(fields, apppool.FieldPoolID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppPoolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apppool.FieldCreatedAt:
		return m.CreatedAt()
	case apppool.FieldUpdatedAt:
		return m.UpdatedAt()
	case apppool.FieldDeletedAt:
		return m.DeletedAt()
	case apppool.FieldEntID:
		return m.EntID()
	case apppool.FieldAppID:
		return m.AppID()
	case apppool.FieldPoolID:
		return m.PoolID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppPoolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apppool.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apppool.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apppool.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case apppool.FieldEntID:
		return m.OldEntID(ctx)
	case apppool.FieldAppID:
		return m.OldAppID(ctx)
	case apppool.FieldPoolID:
		return m.OldPoolID(ctx)
	}
	return nil, fmt.Errorf("unknown AppPool field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPoolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apppool.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apppool.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apppool.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case apppool.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case apppool.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case apppool.FieldPoolID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoolID(v)
		return nil
	}
	return fmt.Errorf("unknown AppPool field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppPoolMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, apppool.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, apppool.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, apppool.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppPoolMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apppool.FieldCreatedAt:
		return m.AddedCreatedAt()
	case apppool.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case apppool.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPoolMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apppool.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case apppool.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case apppool.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppPool numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppPoolMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppPoolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppPoolMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppPool nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppPoolMutation) ResetField(name string) error {
	switch name {
	case apppool.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apppool.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apppool.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case apppool.FieldEntID:
		m.ResetEntID()
		return nil
	case apppool.FieldAppID:
		m.ResetAppID()
		return nil
	case apppool.FieldPoolID:
		m.ResetPoolID()
		return nil
	}
	return fmt.Errorf("unknown AppPool field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppPoolMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppPoolMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppPoolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppPoolMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppPoolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppPoolMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppPoolMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppPool unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppPoolMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppPool edge %s", name)
}

// CoinMutation represents an operation that mutates the Coin nodes in the graph.
type CoinMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint32
	created_at         *uint32
	addcreated_at      *int32
	updated_at         *uint32
	addupdated_at      *int32
	deleted_at         *uint32
	adddeleted_at      *int32
	ent_id             *uuid.UUID
	miningpool_type    *string
	coin_type          *string
	revenue_types      *[]string
	fee_rate           *decimal.Decimal
	fixed_revenue_able *bool
	remark             *string
	threshold          *decimal.Decimal
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Coin, error)
	predicates         []predicate.Coin
}

var _ ent.Mutation = (*CoinMutation)(nil)

// coinOption allows management of the mutation configuration using functional options.
type coinOption func(*CoinMutation)

// newCoinMutation creates new mutation for the Coin entity.
func newCoinMutation(c config, op Op, opts ...coinOption) *CoinMutation {
	m := &CoinMutation{
		config:        c,
		op:            op,
		typ:           TypeCoin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCoinID sets the ID field of the mutation.
func withCoinID(id uint32) coinOption {
	return func(m *CoinMutation) {
		var (
			err   error
			once  sync.Once
			value *Coin
		)
		m.oldValue = func(ctx context.Context) (*Coin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Coin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoin sets the old Coin of the mutation.
func withCoin(node *Coin) coinOption {
	return func(m *CoinMutation) {
		m.oldValue = func(context.Context) (*Coin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CoinMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CoinMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Coin entities.
func (m *CoinMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CoinMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CoinMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Coin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CoinMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CoinMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *CoinMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *CoinMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CoinMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CoinMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CoinMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *CoinMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *CoinMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CoinMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CoinMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CoinMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *CoinMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *CoinMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CoinMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *CoinMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *CoinMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *CoinMutation) ResetEntID() {
	m.ent_id = nil
}

// SetMiningpoolType sets the "miningpool_type" field.
func (m *CoinMutation) SetMiningpoolType(s string) {
	m.miningpool_type = &s
}

// MiningpoolType returns the value of the "miningpool_type" field in the mutation.
func (m *CoinMutation) MiningpoolType() (r string, exists bool) {
	v := m.miningpool_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMiningpoolType returns the old "miningpool_type" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldMiningpoolType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMiningpoolType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMiningpoolType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiningpoolType: %w", err)
	}
	return oldValue.MiningpoolType, nil
}

// ResetMiningpoolType resets all changes to the "miningpool_type" field.
func (m *CoinMutation) ResetMiningpoolType() {
	m.miningpool_type = nil
}

// SetCoinType sets the "coin_type" field.
func (m *CoinMutation) SetCoinType(s string) {
	m.coin_type = &s
}

// CoinType returns the value of the "coin_type" field in the mutation.
func (m *CoinMutation) CoinType() (r string, exists bool) {
	v := m.coin_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinType returns the old "coin_type" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldCoinType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinType: %w", err)
	}
	return oldValue.CoinType, nil
}

// ResetCoinType resets all changes to the "coin_type" field.
func (m *CoinMutation) ResetCoinType() {
	m.coin_type = nil
}

// SetRevenueTypes sets the "revenue_types" field.
func (m *CoinMutation) SetRevenueTypes(s []string) {
	m.revenue_types = &s
}

// RevenueTypes returns the value of the "revenue_types" field in the mutation.
func (m *CoinMutation) RevenueTypes() (r []string, exists bool) {
	v := m.revenue_types
	if v == nil {
		return
	}
	return *v, true
}

// OldRevenueTypes returns the old "revenue_types" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldRevenueTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevenueTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevenueTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevenueTypes: %w", err)
	}
	return oldValue.RevenueTypes, nil
}

// ClearRevenueTypes clears the value of the "revenue_types" field.
func (m *CoinMutation) ClearRevenueTypes() {
	m.revenue_types = nil
	m.clearedFields[coin.FieldRevenueTypes] = struct{}{}
}

// RevenueTypesCleared returns if the "revenue_types" field was cleared in this mutation.
func (m *CoinMutation) RevenueTypesCleared() bool {
	_, ok := m.clearedFields[coin.FieldRevenueTypes]
	return ok
}

// ResetRevenueTypes resets all changes to the "revenue_types" field.
func (m *CoinMutation) ResetRevenueTypes() {
	m.revenue_types = nil
	delete(m.clearedFields, coin.FieldRevenueTypes)
}

// SetFeeRate sets the "fee_rate" field.
func (m *CoinMutation) SetFeeRate(d decimal.Decimal) {
	m.fee_rate = &d
}

// FeeRate returns the value of the "fee_rate" field in the mutation.
func (m *CoinMutation) FeeRate() (r decimal.Decimal, exists bool) {
	v := m.fee_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldFeeRate returns the old "fee_rate" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldFeeRate(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeeRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeeRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeeRate: %w", err)
	}
	return oldValue.FeeRate, nil
}

// ClearFeeRate clears the value of the "fee_rate" field.
func (m *CoinMutation) ClearFeeRate() {
	m.fee_rate = nil
	m.clearedFields[coin.FieldFeeRate] = struct{}{}
}

// FeeRateCleared returns if the "fee_rate" field was cleared in this mutation.
func (m *CoinMutation) FeeRateCleared() bool {
	_, ok := m.clearedFields[coin.FieldFeeRate]
	return ok
}

// ResetFeeRate resets all changes to the "fee_rate" field.
func (m *CoinMutation) ResetFeeRate() {
	m.fee_rate = nil
	delete(m.clearedFields, coin.FieldFeeRate)
}

// SetFixedRevenueAble sets the "fixed_revenue_able" field.
func (m *CoinMutation) SetFixedRevenueAble(b bool) {
	m.fixed_revenue_able = &b
}

// FixedRevenueAble returns the value of the "fixed_revenue_able" field in the mutation.
func (m *CoinMutation) FixedRevenueAble() (r bool, exists bool) {
	v := m.fixed_revenue_able
	if v == nil {
		return
	}
	return *v, true
}

// OldFixedRevenueAble returns the old "fixed_revenue_able" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldFixedRevenueAble(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFixedRevenueAble is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFixedRevenueAble requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixedRevenueAble: %w", err)
	}
	return oldValue.FixedRevenueAble, nil
}

// ClearFixedRevenueAble clears the value of the "fixed_revenue_able" field.
func (m *CoinMutation) ClearFixedRevenueAble() {
	m.fixed_revenue_able = nil
	m.clearedFields[coin.FieldFixedRevenueAble] = struct{}{}
}

// FixedRevenueAbleCleared returns if the "fixed_revenue_able" field was cleared in this mutation.
func (m *CoinMutation) FixedRevenueAbleCleared() bool {
	_, ok := m.clearedFields[coin.FieldFixedRevenueAble]
	return ok
}

// ResetFixedRevenueAble resets all changes to the "fixed_revenue_able" field.
func (m *CoinMutation) ResetFixedRevenueAble() {
	m.fixed_revenue_able = nil
	delete(m.clearedFields, coin.FieldFixedRevenueAble)
}

// SetRemark sets the "remark" field.
func (m *CoinMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CoinMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CoinMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[coin.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CoinMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[coin.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CoinMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, coin.FieldRemark)
}

// SetThreshold sets the "threshold" field.
func (m *CoinMutation) SetThreshold(d decimal.Decimal) {
	m.threshold = &d
}

// Threshold returns the value of the "threshold" field in the mutation.
func (m *CoinMutation) Threshold() (r decimal.Decimal, exists bool) {
	v := m.threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldThreshold returns the old "threshold" field's value of the Coin entity.
// If the Coin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoinMutation) OldThreshold(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreshold: %w", err)
	}
	return oldValue.Threshold, nil
}

// ClearThreshold clears the value of the "threshold" field.
func (m *CoinMutation) ClearThreshold() {
	m.threshold = nil
	m.clearedFields[coin.FieldThreshold] = struct{}{}
}

// ThresholdCleared returns if the "threshold" field was cleared in this mutation.
func (m *CoinMutation) ThresholdCleared() bool {
	_, ok := m.clearedFields[coin.FieldThreshold]
	return ok
}

// ResetThreshold resets all changes to the "threshold" field.
func (m *CoinMutation) ResetThreshold() {
	m.threshold = nil
	delete(m.clearedFields, coin.FieldThreshold)
}

// Where appends a list predicates to the CoinMutation builder.
func (m *CoinMutation) Where(ps ...predicate.Coin) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CoinMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Coin).
func (m *CoinMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CoinMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, coin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, coin.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, coin.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, coin.FieldEntID)
	}
	if m.miningpool_type != nil {
		fields = append(fields, coin.FieldMiningpoolType)
	}
	if m.coin_type != nil {
		fields = append(fields, coin.FieldCoinType)
	}
	if m.revenue_types != nil {
		fields = append(fields, coin.FieldRevenueTypes)
	}
	if m.fee_rate != nil {
		fields = append(fields, coin.FieldFeeRate)
	}
	if m.fixed_revenue_able != nil {
		fields = append(fields, coin.FieldFixedRevenueAble)
	}
	if m.remark != nil {
		fields = append(fields, coin.FieldRemark)
	}
	if m.threshold != nil {
		fields = append(fields, coin.FieldThreshold)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CoinMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coin.FieldCreatedAt:
		return m.CreatedAt()
	case coin.FieldUpdatedAt:
		return m.UpdatedAt()
	case coin.FieldDeletedAt:
		return m.DeletedAt()
	case coin.FieldEntID:
		return m.EntID()
	case coin.FieldMiningpoolType:
		return m.MiningpoolType()
	case coin.FieldCoinType:
		return m.CoinType()
	case coin.FieldRevenueTypes:
		return m.RevenueTypes()
	case coin.FieldFeeRate:
		return m.FeeRate()
	case coin.FieldFixedRevenueAble:
		return m.FixedRevenueAble()
	case coin.FieldRemark:
		return m.Remark()
	case coin.FieldThreshold:
		return m.Threshold()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CoinMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case coin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case coin.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case coin.FieldEntID:
		return m.OldEntID(ctx)
	case coin.FieldMiningpoolType:
		return m.OldMiningpoolType(ctx)
	case coin.FieldCoinType:
		return m.OldCoinType(ctx)
	case coin.FieldRevenueTypes:
		return m.OldRevenueTypes(ctx)
	case coin.FieldFeeRate:
		return m.OldFeeRate(ctx)
	case coin.FieldFixedRevenueAble:
		return m.OldFixedRevenueAble(ctx)
	case coin.FieldRemark:
		return m.OldRemark(ctx)
	case coin.FieldThreshold:
		return m.OldThreshold(ctx)
	}
	return nil, fmt.Errorf("unknown Coin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CoinMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coin.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case coin.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case coin.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case coin.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case coin.FieldMiningpoolType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiningpoolType(v)
		return nil
	case coin.FieldCoinType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinType(v)
		return nil
	case coin.FieldRevenueTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevenueTypes(v)
		return nil
	case coin.FieldFeeRate:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeeRate(v)
		return nil
	case coin.FieldFixedRevenueAble:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixedRevenueAble(v)
		return nil
	case coin.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case coin.FieldThreshold:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreshold(v)
		return nil
	}
	return fmt.Errorf("unknown Coin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CoinMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, coin.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, coin.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, coin.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CoinMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coin.FieldCreatedAt:
		return m.AddedCreatedAt()
	case coin.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case coin.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CoinMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coin.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case coin.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case coin.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Coin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CoinMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coin.FieldRevenueTypes) {
		fields = append(fields, coin.FieldRevenueTypes)
	}
	if m.FieldCleared(coin.FieldFeeRate) {
		fields = append(fields, coin.FieldFeeRate)
	}
	if m.FieldCleared(coin.FieldFixedRevenueAble) {
		fields = append(fields, coin.FieldFixedRevenueAble)
	}
	if m.FieldCleared(coin.FieldRemark) {
		fields = append(fields, coin.FieldRemark)
	}
	if m.FieldCleared(coin.FieldThreshold) {
		fields = append(fields, coin.FieldThreshold)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CoinMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CoinMutation) ClearField(name string) error {
	switch name {
	case coin.FieldRevenueTypes:
		m.ClearRevenueTypes()
		return nil
	case coin.FieldFeeRate:
		m.ClearFeeRate()
		return nil
	case coin.FieldFixedRevenueAble:
		m.ClearFixedRevenueAble()
		return nil
	case coin.FieldRemark:
		m.ClearRemark()
		return nil
	case coin.FieldThreshold:
		m.ClearThreshold()
		return nil
	}
	return fmt.Errorf("unknown Coin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CoinMutation) ResetField(name string) error {
	switch name {
	case coin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case coin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case coin.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case coin.FieldEntID:
		m.ResetEntID()
		return nil
	case coin.FieldMiningpoolType:
		m.ResetMiningpoolType()
		return nil
	case coin.FieldCoinType:
		m.ResetCoinType()
		return nil
	case coin.FieldRevenueTypes:
		m.ResetRevenueTypes()
		return nil
	case coin.FieldFeeRate:
		m.ResetFeeRate()
		return nil
	case coin.FieldFixedRevenueAble:
		m.ResetFixedRevenueAble()
		return nil
	case coin.FieldRemark:
		m.ResetRemark()
		return nil
	case coin.FieldThreshold:
		m.ResetThreshold()
		return nil
	}
	return fmt.Errorf("unknown Coin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CoinMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CoinMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CoinMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CoinMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CoinMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CoinMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CoinMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Coin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CoinMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Coin edge %s", name)
}

// FractionMutation represents an operation that mutates the Fraction nodes in the graph.
type FractionMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *uint32
	addcreated_at    *int32
	updated_at       *uint32
	addupdated_at    *int32
	deleted_at       *uint32
	adddeleted_at    *int32
	ent_id           *uuid.UUID
	app_id           *uuid.UUID
	user_id          *uuid.UUID
	order_user_id    *uuid.UUID
	withdraw_state   *string
	withdraw_time    *uint32
	addwithdraw_time *int32
	pay_time         *uint32
	addpay_time      *int32
	msg              *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Fraction, error)
	predicates       []predicate.Fraction
}

var _ ent.Mutation = (*FractionMutation)(nil)

// fractionOption allows management of the mutation configuration using functional options.
type fractionOption func(*FractionMutation)

// newFractionMutation creates new mutation for the Fraction entity.
func newFractionMutation(c config, op Op, opts ...fractionOption) *FractionMutation {
	m := &FractionMutation{
		config:        c,
		op:            op,
		typ:           TypeFraction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFractionID sets the ID field of the mutation.
func withFractionID(id uint32) fractionOption {
	return func(m *FractionMutation) {
		var (
			err   error
			once  sync.Once
			value *Fraction
		)
		m.oldValue = func(ctx context.Context) (*Fraction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Fraction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFraction sets the old Fraction of the mutation.
func withFraction(node *Fraction) fractionOption {
	return func(m *FractionMutation) {
		m.oldValue = func(context.Context) (*Fraction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FractionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FractionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Fraction entities.
func (m *FractionMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FractionMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FractionMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Fraction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FractionMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FractionMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Fraction entity.
// If the Fraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *FractionMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *FractionMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FractionMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FractionMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FractionMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Fraction entity.
// If the Fraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *FractionMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *FractionMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FractionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FractionMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FractionMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Fraction entity.
// If the Fraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *FractionMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *FractionMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FractionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *FractionMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *FractionMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Fraction entity.
// If the Fraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *FractionMutation) ResetEntID() {
	m.ent_id = nil
}

// SetAppID sets the "app_id" field.
func (m *FractionMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *FractionMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Fraction entity.
// If the Fraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *FractionMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *FractionMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FractionMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Fraction entity.
// If the Fraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FractionMutation) ResetUserID() {
	m.user_id = nil
}

// SetOrderUserID sets the "order_user_id" field.
func (m *FractionMutation) SetOrderUserID(u uuid.UUID) {
	m.order_user_id = &u
}

// OrderUserID returns the value of the "order_user_id" field in the mutation.
func (m *FractionMutation) OrderUserID() (r uuid.UUID, exists bool) {
	v := m.order_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderUserID returns the old "order_user_id" field's value of the Fraction entity.
// If the Fraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionMutation) OldOrderUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderUserID: %w", err)
	}
	return oldValue.OrderUserID, nil
}

// ResetOrderUserID resets all changes to the "order_user_id" field.
func (m *FractionMutation) ResetOrderUserID() {
	m.order_user_id = nil
}

// SetWithdrawState sets the "withdraw_state" field.
func (m *FractionMutation) SetWithdrawState(s string) {
	m.withdraw_state = &s
}

// WithdrawState returns the value of the "withdraw_state" field in the mutation.
func (m *FractionMutation) WithdrawState() (r string, exists bool) {
	v := m.withdraw_state
	if v == nil {
		return
	}
	return *v, true
}

// OldWithdrawState returns the old "withdraw_state" field's value of the Fraction entity.
// If the Fraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionMutation) OldWithdrawState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithdrawState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithdrawState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithdrawState: %w", err)
	}
	return oldValue.WithdrawState, nil
}

// ResetWithdrawState resets all changes to the "withdraw_state" field.
func (m *FractionMutation) ResetWithdrawState() {
	m.withdraw_state = nil
}

// SetWithdrawTime sets the "withdraw_time" field.
func (m *FractionMutation) SetWithdrawTime(u uint32) {
	m.withdraw_time = &u
	m.addwithdraw_time = nil
}

// WithdrawTime returns the value of the "withdraw_time" field in the mutation.
func (m *FractionMutation) WithdrawTime() (r uint32, exists bool) {
	v := m.withdraw_time
	if v == nil {
		return
	}
	return *v, true
}

// OldWithdrawTime returns the old "withdraw_time" field's value of the Fraction entity.
// If the Fraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionMutation) OldWithdrawTime(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithdrawTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithdrawTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithdrawTime: %w", err)
	}
	return oldValue.WithdrawTime, nil
}

// AddWithdrawTime adds u to the "withdraw_time" field.
func (m *FractionMutation) AddWithdrawTime(u int32) {
	if m.addwithdraw_time != nil {
		*m.addwithdraw_time += u
	} else {
		m.addwithdraw_time = &u
	}
}

// AddedWithdrawTime returns the value that was added to the "withdraw_time" field in this mutation.
func (m *FractionMutation) AddedWithdrawTime() (r int32, exists bool) {
	v := m.addwithdraw_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetWithdrawTime resets all changes to the "withdraw_time" field.
func (m *FractionMutation) ResetWithdrawTime() {
	m.withdraw_time = nil
	m.addwithdraw_time = nil
}

// SetPayTime sets the "pay_time" field.
func (m *FractionMutation) SetPayTime(u uint32) {
	m.pay_time = &u
	m.addpay_time = nil
}

// PayTime returns the value of the "pay_time" field in the mutation.
func (m *FractionMutation) PayTime() (r uint32, exists bool) {
	v := m.pay_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPayTime returns the old "pay_time" field's value of the Fraction entity.
// If the Fraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionMutation) OldPayTime(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayTime: %w", err)
	}
	return oldValue.PayTime, nil
}

// AddPayTime adds u to the "pay_time" field.
func (m *FractionMutation) AddPayTime(u int32) {
	if m.addpay_time != nil {
		*m.addpay_time += u
	} else {
		m.addpay_time = &u
	}
}

// AddedPayTime returns the value that was added to the "pay_time" field in this mutation.
func (m *FractionMutation) AddedPayTime() (r int32, exists bool) {
	v := m.addpay_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayTime clears the value of the "pay_time" field.
func (m *FractionMutation) ClearPayTime() {
	m.pay_time = nil
	m.addpay_time = nil
	m.clearedFields[fraction.FieldPayTime] = struct{}{}
}

// PayTimeCleared returns if the "pay_time" field was cleared in this mutation.
func (m *FractionMutation) PayTimeCleared() bool {
	_, ok := m.clearedFields[fraction.FieldPayTime]
	return ok
}

// ResetPayTime resets all changes to the "pay_time" field.
func (m *FractionMutation) ResetPayTime() {
	m.pay_time = nil
	m.addpay_time = nil
	delete(m.clearedFields, fraction.FieldPayTime)
}

// SetMsg sets the "msg" field.
func (m *FractionMutation) SetMsg(s string) {
	m.msg = &s
}

// Msg returns the value of the "msg" field in the mutation.
func (m *FractionMutation) Msg() (r string, exists bool) {
	v := m.msg
	if v == nil {
		return
	}
	return *v, true
}

// OldMsg returns the old "msg" field's value of the Fraction entity.
// If the Fraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionMutation) OldMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMsg: %w", err)
	}
	return oldValue.Msg, nil
}

// ClearMsg clears the value of the "msg" field.
func (m *FractionMutation) ClearMsg() {
	m.msg = nil
	m.clearedFields[fraction.FieldMsg] = struct{}{}
}

// MsgCleared returns if the "msg" field was cleared in this mutation.
func (m *FractionMutation) MsgCleared() bool {
	_, ok := m.clearedFields[fraction.FieldMsg]
	return ok
}

// ResetMsg resets all changes to the "msg" field.
func (m *FractionMutation) ResetMsg() {
	m.msg = nil
	delete(m.clearedFields, fraction.FieldMsg)
}

// Where appends a list predicates to the FractionMutation builder.
func (m *FractionMutation) Where(ps ...predicate.Fraction) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FractionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Fraction).
func (m *FractionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FractionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, fraction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, fraction.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, fraction.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, fraction.FieldEntID)
	}
	if m.app_id != nil {
		fields = append(fields, fraction.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, fraction.FieldUserID)
	}
	if m.order_user_id != nil {
		fields = append(fields, fraction.FieldOrderUserID)
	}
	if m.withdraw_state != nil {
		fields = append(fields, fraction.FieldWithdrawState)
	}
	if m.withdraw_time != nil {
		fields = append(fields, fraction.FieldWithdrawTime)
	}
	if m.pay_time != nil {
		fields = append(fields, fraction.FieldPayTime)
	}
	if m.msg != nil {
		fields = append(fields, fraction.FieldMsg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FractionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fraction.FieldCreatedAt:
		return m.CreatedAt()
	case fraction.FieldUpdatedAt:
		return m.UpdatedAt()
	case fraction.FieldDeletedAt:
		return m.DeletedAt()
	case fraction.FieldEntID:
		return m.EntID()
	case fraction.FieldAppID:
		return m.AppID()
	case fraction.FieldUserID:
		return m.UserID()
	case fraction.FieldOrderUserID:
		return m.OrderUserID()
	case fraction.FieldWithdrawState:
		return m.WithdrawState()
	case fraction.FieldWithdrawTime:
		return m.WithdrawTime()
	case fraction.FieldPayTime:
		return m.PayTime()
	case fraction.FieldMsg:
		return m.Msg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FractionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fraction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case fraction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case fraction.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case fraction.FieldEntID:
		return m.OldEntID(ctx)
	case fraction.FieldAppID:
		return m.OldAppID(ctx)
	case fraction.FieldUserID:
		return m.OldUserID(ctx)
	case fraction.FieldOrderUserID:
		return m.OldOrderUserID(ctx)
	case fraction.FieldWithdrawState:
		return m.OldWithdrawState(ctx)
	case fraction.FieldWithdrawTime:
		return m.OldWithdrawTime(ctx)
	case fraction.FieldPayTime:
		return m.OldPayTime(ctx)
	case fraction.FieldMsg:
		return m.OldMsg(ctx)
	}
	return nil, fmt.Errorf("unknown Fraction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FractionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fraction.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case fraction.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case fraction.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case fraction.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case fraction.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case fraction.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case fraction.FieldOrderUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderUserID(v)
		return nil
	case fraction.FieldWithdrawState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithdrawState(v)
		return nil
	case fraction.FieldWithdrawTime:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithdrawTime(v)
		return nil
	case fraction.FieldPayTime:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayTime(v)
		return nil
	case fraction.FieldMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMsg(v)
		return nil
	}
	return fmt.Errorf("unknown Fraction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FractionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, fraction.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, fraction.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, fraction.FieldDeletedAt)
	}
	if m.addwithdraw_time != nil {
		fields = append(fields, fraction.FieldWithdrawTime)
	}
	if m.addpay_time != nil {
		fields = append(fields, fraction.FieldPayTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FractionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fraction.FieldCreatedAt:
		return m.AddedCreatedAt()
	case fraction.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case fraction.FieldDeletedAt:
		return m.AddedDeletedAt()
	case fraction.FieldWithdrawTime:
		return m.AddedWithdrawTime()
	case fraction.FieldPayTime:
		return m.AddedPayTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FractionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fraction.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case fraction.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case fraction.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case fraction.FieldWithdrawTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWithdrawTime(v)
		return nil
	case fraction.FieldPayTime:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayTime(v)
		return nil
	}
	return fmt.Errorf("unknown Fraction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FractionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fraction.FieldPayTime) {
		fields = append(fields, fraction.FieldPayTime)
	}
	if m.FieldCleared(fraction.FieldMsg) {
		fields = append(fields, fraction.FieldMsg)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FractionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FractionMutation) ClearField(name string) error {
	switch name {
	case fraction.FieldPayTime:
		m.ClearPayTime()
		return nil
	case fraction.FieldMsg:
		m.ClearMsg()
		return nil
	}
	return fmt.Errorf("unknown Fraction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FractionMutation) ResetField(name string) error {
	switch name {
	case fraction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case fraction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case fraction.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case fraction.FieldEntID:
		m.ResetEntID()
		return nil
	case fraction.FieldAppID:
		m.ResetAppID()
		return nil
	case fraction.FieldUserID:
		m.ResetUserID()
		return nil
	case fraction.FieldOrderUserID:
		m.ResetOrderUserID()
		return nil
	case fraction.FieldWithdrawState:
		m.ResetWithdrawState()
		return nil
	case fraction.FieldWithdrawTime:
		m.ResetWithdrawTime()
		return nil
	case fraction.FieldPayTime:
		m.ResetPayTime()
		return nil
	case fraction.FieldMsg:
		m.ResetMsg()
		return nil
	}
	return fmt.Errorf("unknown Fraction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FractionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FractionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FractionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FractionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FractionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FractionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FractionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Fraction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FractionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Fraction edge %s", name)
}

// FractionRuleMutation represents an operation that mutates the FractionRule nodes in the graph.
type FractionRuleMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	created_at           *uint32
	addcreated_at        *int32
	updated_at           *uint32
	addupdated_at        *int32
	deleted_at           *uint32
	adddeleted_at        *int32
	ent_id               *uuid.UUID
	miningpool_type      *string
	coin_type            *string
	withdraw_interval    *uint32
	addwithdraw_interval *int32
	min_amount           *float32
	addmin_amount        *float32
	withdraw_rate        *float32
	addwithdraw_rate     *float32
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*FractionRule, error)
	predicates           []predicate.FractionRule
}

var _ ent.Mutation = (*FractionRuleMutation)(nil)

// fractionruleOption allows management of the mutation configuration using functional options.
type fractionruleOption func(*FractionRuleMutation)

// newFractionRuleMutation creates new mutation for the FractionRule entity.
func newFractionRuleMutation(c config, op Op, opts ...fractionruleOption) *FractionRuleMutation {
	m := &FractionRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeFractionRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFractionRuleID sets the ID field of the mutation.
func withFractionRuleID(id uint32) fractionruleOption {
	return func(m *FractionRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *FractionRule
		)
		m.oldValue = func(ctx context.Context) (*FractionRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FractionRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFractionRule sets the old FractionRule of the mutation.
func withFractionRule(node *FractionRule) fractionruleOption {
	return func(m *FractionRuleMutation) {
		m.oldValue = func(context.Context) (*FractionRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FractionRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FractionRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FractionRule entities.
func (m *FractionRuleMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FractionRuleMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FractionRuleMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FractionRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FractionRuleMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FractionRuleMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FractionRule entity.
// If the FractionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionRuleMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *FractionRuleMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *FractionRuleMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FractionRuleMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FractionRuleMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FractionRuleMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FractionRule entity.
// If the FractionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionRuleMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *FractionRuleMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *FractionRuleMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FractionRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FractionRuleMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FractionRuleMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FractionRule entity.
// If the FractionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionRuleMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *FractionRuleMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *FractionRuleMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FractionRuleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *FractionRuleMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *FractionRuleMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the FractionRule entity.
// If the FractionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionRuleMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *FractionRuleMutation) ResetEntID() {
	m.ent_id = nil
}

// SetMiningpoolType sets the "miningpool_type" field.
func (m *FractionRuleMutation) SetMiningpoolType(s string) {
	m.miningpool_type = &s
}

// MiningpoolType returns the value of the "miningpool_type" field in the mutation.
func (m *FractionRuleMutation) MiningpoolType() (r string, exists bool) {
	v := m.miningpool_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMiningpoolType returns the old "miningpool_type" field's value of the FractionRule entity.
// If the FractionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionRuleMutation) OldMiningpoolType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMiningpoolType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMiningpoolType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiningpoolType: %w", err)
	}
	return oldValue.MiningpoolType, nil
}

// ResetMiningpoolType resets all changes to the "miningpool_type" field.
func (m *FractionRuleMutation) ResetMiningpoolType() {
	m.miningpool_type = nil
}

// SetCoinType sets the "coin_type" field.
func (m *FractionRuleMutation) SetCoinType(s string) {
	m.coin_type = &s
}

// CoinType returns the value of the "coin_type" field in the mutation.
func (m *FractionRuleMutation) CoinType() (r string, exists bool) {
	v := m.coin_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinType returns the old "coin_type" field's value of the FractionRule entity.
// If the FractionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionRuleMutation) OldCoinType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinType: %w", err)
	}
	return oldValue.CoinType, nil
}

// ResetCoinType resets all changes to the "coin_type" field.
func (m *FractionRuleMutation) ResetCoinType() {
	m.coin_type = nil
}

// SetWithdrawInterval sets the "withdraw_interval" field.
func (m *FractionRuleMutation) SetWithdrawInterval(u uint32) {
	m.withdraw_interval = &u
	m.addwithdraw_interval = nil
}

// WithdrawInterval returns the value of the "withdraw_interval" field in the mutation.
func (m *FractionRuleMutation) WithdrawInterval() (r uint32, exists bool) {
	v := m.withdraw_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldWithdrawInterval returns the old "withdraw_interval" field's value of the FractionRule entity.
// If the FractionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionRuleMutation) OldWithdrawInterval(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithdrawInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithdrawInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithdrawInterval: %w", err)
	}
	return oldValue.WithdrawInterval, nil
}

// AddWithdrawInterval adds u to the "withdraw_interval" field.
func (m *FractionRuleMutation) AddWithdrawInterval(u int32) {
	if m.addwithdraw_interval != nil {
		*m.addwithdraw_interval += u
	} else {
		m.addwithdraw_interval = &u
	}
}

// AddedWithdrawInterval returns the value that was added to the "withdraw_interval" field in this mutation.
func (m *FractionRuleMutation) AddedWithdrawInterval() (r int32, exists bool) {
	v := m.addwithdraw_interval
	if v == nil {
		return
	}
	return *v, true
}

// ResetWithdrawInterval resets all changes to the "withdraw_interval" field.
func (m *FractionRuleMutation) ResetWithdrawInterval() {
	m.withdraw_interval = nil
	m.addwithdraw_interval = nil
}

// SetMinAmount sets the "min_amount" field.
func (m *FractionRuleMutation) SetMinAmount(f float32) {
	m.min_amount = &f
	m.addmin_amount = nil
}

// MinAmount returns the value of the "min_amount" field in the mutation.
func (m *FractionRuleMutation) MinAmount() (r float32, exists bool) {
	v := m.min_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldMinAmount returns the old "min_amount" field's value of the FractionRule entity.
// If the FractionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionRuleMutation) OldMinAmount(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinAmount: %w", err)
	}
	return oldValue.MinAmount, nil
}

// AddMinAmount adds f to the "min_amount" field.
func (m *FractionRuleMutation) AddMinAmount(f float32) {
	if m.addmin_amount != nil {
		*m.addmin_amount += f
	} else {
		m.addmin_amount = &f
	}
}

// AddedMinAmount returns the value that was added to the "min_amount" field in this mutation.
func (m *FractionRuleMutation) AddedMinAmount() (r float32, exists bool) {
	v := m.addmin_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinAmount resets all changes to the "min_amount" field.
func (m *FractionRuleMutation) ResetMinAmount() {
	m.min_amount = nil
	m.addmin_amount = nil
}

// SetWithdrawRate sets the "withdraw_rate" field.
func (m *FractionRuleMutation) SetWithdrawRate(f float32) {
	m.withdraw_rate = &f
	m.addwithdraw_rate = nil
}

// WithdrawRate returns the value of the "withdraw_rate" field in the mutation.
func (m *FractionRuleMutation) WithdrawRate() (r float32, exists bool) {
	v := m.withdraw_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldWithdrawRate returns the old "withdraw_rate" field's value of the FractionRule entity.
// If the FractionRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FractionRuleMutation) OldWithdrawRate(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithdrawRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithdrawRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithdrawRate: %w", err)
	}
	return oldValue.WithdrawRate, nil
}

// AddWithdrawRate adds f to the "withdraw_rate" field.
func (m *FractionRuleMutation) AddWithdrawRate(f float32) {
	if m.addwithdraw_rate != nil {
		*m.addwithdraw_rate += f
	} else {
		m.addwithdraw_rate = &f
	}
}

// AddedWithdrawRate returns the value that was added to the "withdraw_rate" field in this mutation.
func (m *FractionRuleMutation) AddedWithdrawRate() (r float32, exists bool) {
	v := m.addwithdraw_rate
	if v == nil {
		return
	}
	return *v, true
}

// ResetWithdrawRate resets all changes to the "withdraw_rate" field.
func (m *FractionRuleMutation) ResetWithdrawRate() {
	m.withdraw_rate = nil
	m.addwithdraw_rate = nil
}

// Where appends a list predicates to the FractionRuleMutation builder.
func (m *FractionRuleMutation) Where(ps ...predicate.FractionRule) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FractionRuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FractionRule).
func (m *FractionRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FractionRuleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, fractionrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, fractionrule.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, fractionrule.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, fractionrule.FieldEntID)
	}
	if m.miningpool_type != nil {
		fields = append(fields, fractionrule.FieldMiningpoolType)
	}
	if m.coin_type != nil {
		fields = append(fields, fractionrule.FieldCoinType)
	}
	if m.withdraw_interval != nil {
		fields = append(fields, fractionrule.FieldWithdrawInterval)
	}
	if m.min_amount != nil {
		fields = append(fields, fractionrule.FieldMinAmount)
	}
	if m.withdraw_rate != nil {
		fields = append(fields, fractionrule.FieldWithdrawRate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FractionRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fractionrule.FieldCreatedAt:
		return m.CreatedAt()
	case fractionrule.FieldUpdatedAt:
		return m.UpdatedAt()
	case fractionrule.FieldDeletedAt:
		return m.DeletedAt()
	case fractionrule.FieldEntID:
		return m.EntID()
	case fractionrule.FieldMiningpoolType:
		return m.MiningpoolType()
	case fractionrule.FieldCoinType:
		return m.CoinType()
	case fractionrule.FieldWithdrawInterval:
		return m.WithdrawInterval()
	case fractionrule.FieldMinAmount:
		return m.MinAmount()
	case fractionrule.FieldWithdrawRate:
		return m.WithdrawRate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FractionRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fractionrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case fractionrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case fractionrule.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case fractionrule.FieldEntID:
		return m.OldEntID(ctx)
	case fractionrule.FieldMiningpoolType:
		return m.OldMiningpoolType(ctx)
	case fractionrule.FieldCoinType:
		return m.OldCoinType(ctx)
	case fractionrule.FieldWithdrawInterval:
		return m.OldWithdrawInterval(ctx)
	case fractionrule.FieldMinAmount:
		return m.OldMinAmount(ctx)
	case fractionrule.FieldWithdrawRate:
		return m.OldWithdrawRate(ctx)
	}
	return nil, fmt.Errorf("unknown FractionRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FractionRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fractionrule.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case fractionrule.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case fractionrule.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case fractionrule.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case fractionrule.FieldMiningpoolType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiningpoolType(v)
		return nil
	case fractionrule.FieldCoinType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinType(v)
		return nil
	case fractionrule.FieldWithdrawInterval:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithdrawInterval(v)
		return nil
	case fractionrule.FieldMinAmount:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinAmount(v)
		return nil
	case fractionrule.FieldWithdrawRate:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithdrawRate(v)
		return nil
	}
	return fmt.Errorf("unknown FractionRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FractionRuleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, fractionrule.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, fractionrule.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, fractionrule.FieldDeletedAt)
	}
	if m.addwithdraw_interval != nil {
		fields = append(fields, fractionrule.FieldWithdrawInterval)
	}
	if m.addmin_amount != nil {
		fields = append(fields, fractionrule.FieldMinAmount)
	}
	if m.addwithdraw_rate != nil {
		fields = append(fields, fractionrule.FieldWithdrawRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FractionRuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fractionrule.FieldCreatedAt:
		return m.AddedCreatedAt()
	case fractionrule.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case fractionrule.FieldDeletedAt:
		return m.AddedDeletedAt()
	case fractionrule.FieldWithdrawInterval:
		return m.AddedWithdrawInterval()
	case fractionrule.FieldMinAmount:
		return m.AddedMinAmount()
	case fractionrule.FieldWithdrawRate:
		return m.AddedWithdrawRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FractionRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fractionrule.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case fractionrule.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case fractionrule.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case fractionrule.FieldWithdrawInterval:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWithdrawInterval(v)
		return nil
	case fractionrule.FieldMinAmount:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinAmount(v)
		return nil
	case fractionrule.FieldWithdrawRate:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWithdrawRate(v)
		return nil
	}
	return fmt.Errorf("unknown FractionRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FractionRuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FractionRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FractionRuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FractionRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FractionRuleMutation) ResetField(name string) error {
	switch name {
	case fractionrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case fractionrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case fractionrule.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case fractionrule.FieldEntID:
		m.ResetEntID()
		return nil
	case fractionrule.FieldMiningpoolType:
		m.ResetMiningpoolType()
		return nil
	case fractionrule.FieldCoinType:
		m.ResetCoinType()
		return nil
	case fractionrule.FieldWithdrawInterval:
		m.ResetWithdrawInterval()
		return nil
	case fractionrule.FieldMinAmount:
		m.ResetMinAmount()
		return nil
	case fractionrule.FieldWithdrawRate:
		m.ResetWithdrawRate()
		return nil
	}
	return fmt.Errorf("unknown FractionRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FractionRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FractionRuleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FractionRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FractionRuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FractionRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FractionRuleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FractionRuleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FractionRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FractionRuleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FractionRule edge %s", name)
}

// GoodUserMutation represents an operation that mutates the GoodUser nodes in the graph.
type GoodUserMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	ent_id          *uuid.UUID
	root_user_id    *uuid.UUID
	name            *string
	miningpool_type *string
	coin_type       *string
	hash_rate       *float32
	addhash_rate    *float32
	read_page_link  *string
	revenue_type    *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*GoodUser, error)
	predicates      []predicate.GoodUser
}

var _ ent.Mutation = (*GoodUserMutation)(nil)

// gooduserOption allows management of the mutation configuration using functional options.
type gooduserOption func(*GoodUserMutation)

// newGoodUserMutation creates new mutation for the GoodUser entity.
func newGoodUserMutation(c config, op Op, opts ...gooduserOption) *GoodUserMutation {
	m := &GoodUserMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodUserID sets the ID field of the mutation.
func withGoodUserID(id uint32) gooduserOption {
	return func(m *GoodUserMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodUser
		)
		m.oldValue = func(ctx context.Context) (*GoodUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodUser sets the old GoodUser of the mutation.
func withGoodUser(node *GoodUser) gooduserOption {
	return func(m *GoodUserMutation) {
		m.oldValue = func(context.Context) (*GoodUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodUser entities.
func (m *GoodUserMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodUserMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodUserMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GoodUserMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoodUserMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoodUser entity.
// If the GoodUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodUserMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *GoodUserMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *GoodUserMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoodUserMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoodUserMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoodUserMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoodUser entity.
// If the GoodUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodUserMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *GoodUserMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *GoodUserMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoodUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GoodUserMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GoodUserMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GoodUser entity.
// If the GoodUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodUserMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *GoodUserMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *GoodUserMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GoodUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *GoodUserMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *GoodUserMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the GoodUser entity.
// If the GoodUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodUserMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *GoodUserMutation) ResetEntID() {
	m.ent_id = nil
}

// SetRootUserID sets the "root_user_id" field.
func (m *GoodUserMutation) SetRootUserID(u uuid.UUID) {
	m.root_user_id = &u
}

// RootUserID returns the value of the "root_user_id" field in the mutation.
func (m *GoodUserMutation) RootUserID() (r uuid.UUID, exists bool) {
	v := m.root_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRootUserID returns the old "root_user_id" field's value of the GoodUser entity.
// If the GoodUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodUserMutation) OldRootUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootUserID: %w", err)
	}
	return oldValue.RootUserID, nil
}

// ResetRootUserID resets all changes to the "root_user_id" field.
func (m *GoodUserMutation) ResetRootUserID() {
	m.root_user_id = nil
}

// SetName sets the "name" field.
func (m *GoodUserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GoodUserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GoodUser entity.
// If the GoodUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodUserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GoodUserMutation) ResetName() {
	m.name = nil
}

// SetMiningpoolType sets the "miningpool_type" field.
func (m *GoodUserMutation) SetMiningpoolType(s string) {
	m.miningpool_type = &s
}

// MiningpoolType returns the value of the "miningpool_type" field in the mutation.
func (m *GoodUserMutation) MiningpoolType() (r string, exists bool) {
	v := m.miningpool_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMiningpoolType returns the old "miningpool_type" field's value of the GoodUser entity.
// If the GoodUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodUserMutation) OldMiningpoolType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMiningpoolType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMiningpoolType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiningpoolType: %w", err)
	}
	return oldValue.MiningpoolType, nil
}

// ResetMiningpoolType resets all changes to the "miningpool_type" field.
func (m *GoodUserMutation) ResetMiningpoolType() {
	m.miningpool_type = nil
}

// SetCoinType sets the "coin_type" field.
func (m *GoodUserMutation) SetCoinType(s string) {
	m.coin_type = &s
}

// CoinType returns the value of the "coin_type" field in the mutation.
func (m *GoodUserMutation) CoinType() (r string, exists bool) {
	v := m.coin_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinType returns the old "coin_type" field's value of the GoodUser entity.
// If the GoodUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodUserMutation) OldCoinType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinType: %w", err)
	}
	return oldValue.CoinType, nil
}

// ResetCoinType resets all changes to the "coin_type" field.
func (m *GoodUserMutation) ResetCoinType() {
	m.coin_type = nil
}

// SetHashRate sets the "hash_rate" field.
func (m *GoodUserMutation) SetHashRate(f float32) {
	m.hash_rate = &f
	m.addhash_rate = nil
}

// HashRate returns the value of the "hash_rate" field in the mutation.
func (m *GoodUserMutation) HashRate() (r float32, exists bool) {
	v := m.hash_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldHashRate returns the old "hash_rate" field's value of the GoodUser entity.
// If the GoodUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodUserMutation) OldHashRate(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashRate: %w", err)
	}
	return oldValue.HashRate, nil
}

// AddHashRate adds f to the "hash_rate" field.
func (m *GoodUserMutation) AddHashRate(f float32) {
	if m.addhash_rate != nil {
		*m.addhash_rate += f
	} else {
		m.addhash_rate = &f
	}
}

// AddedHashRate returns the value that was added to the "hash_rate" field in this mutation.
func (m *GoodUserMutation) AddedHashRate() (r float32, exists bool) {
	v := m.addhash_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearHashRate clears the value of the "hash_rate" field.
func (m *GoodUserMutation) ClearHashRate() {
	m.hash_rate = nil
	m.addhash_rate = nil
	m.clearedFields[gooduser.FieldHashRate] = struct{}{}
}

// HashRateCleared returns if the "hash_rate" field was cleared in this mutation.
func (m *GoodUserMutation) HashRateCleared() bool {
	_, ok := m.clearedFields[gooduser.FieldHashRate]
	return ok
}

// ResetHashRate resets all changes to the "hash_rate" field.
func (m *GoodUserMutation) ResetHashRate() {
	m.hash_rate = nil
	m.addhash_rate = nil
	delete(m.clearedFields, gooduser.FieldHashRate)
}

// SetReadPageLink sets the "read_page_link" field.
func (m *GoodUserMutation) SetReadPageLink(s string) {
	m.read_page_link = &s
}

// ReadPageLink returns the value of the "read_page_link" field in the mutation.
func (m *GoodUserMutation) ReadPageLink() (r string, exists bool) {
	v := m.read_page_link
	if v == nil {
		return
	}
	return *v, true
}

// OldReadPageLink returns the old "read_page_link" field's value of the GoodUser entity.
// If the GoodUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodUserMutation) OldReadPageLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadPageLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadPageLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadPageLink: %w", err)
	}
	return oldValue.ReadPageLink, nil
}

// ResetReadPageLink resets all changes to the "read_page_link" field.
func (m *GoodUserMutation) ResetReadPageLink() {
	m.read_page_link = nil
}

// SetRevenueType sets the "revenue_type" field.
func (m *GoodUserMutation) SetRevenueType(s string) {
	m.revenue_type = &s
}

// RevenueType returns the value of the "revenue_type" field in the mutation.
func (m *GoodUserMutation) RevenueType() (r string, exists bool) {
	v := m.revenue_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRevenueType returns the old "revenue_type" field's value of the GoodUser entity.
// If the GoodUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodUserMutation) OldRevenueType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevenueType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevenueType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevenueType: %w", err)
	}
	return oldValue.RevenueType, nil
}

// ResetRevenueType resets all changes to the "revenue_type" field.
func (m *GoodUserMutation) ResetRevenueType() {
	m.revenue_type = nil
}

// Where appends a list predicates to the GoodUserMutation builder.
func (m *GoodUserMutation) Where(ps ...predicate.GoodUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GoodUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodUser).
func (m *GoodUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodUserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, gooduser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, gooduser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, gooduser.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, gooduser.FieldEntID)
	}
	if m.root_user_id != nil {
		fields = append(fields, gooduser.FieldRootUserID)
	}
	if m.name != nil {
		fields = append(fields, gooduser.FieldName)
	}
	if m.miningpool_type != nil {
		fields = append(fields, gooduser.FieldMiningpoolType)
	}
	if m.coin_type != nil {
		fields = append(fields, gooduser.FieldCoinType)
	}
	if m.hash_rate != nil {
		fields = append(fields, gooduser.FieldHashRate)
	}
	if m.read_page_link != nil {
		fields = append(fields, gooduser.FieldReadPageLink)
	}
	if m.revenue_type != nil {
		fields = append(fields, gooduser.FieldRevenueType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gooduser.FieldCreatedAt:
		return m.CreatedAt()
	case gooduser.FieldUpdatedAt:
		return m.UpdatedAt()
	case gooduser.FieldDeletedAt:
		return m.DeletedAt()
	case gooduser.FieldEntID:
		return m.EntID()
	case gooduser.FieldRootUserID:
		return m.RootUserID()
	case gooduser.FieldName:
		return m.Name()
	case gooduser.FieldMiningpoolType:
		return m.MiningpoolType()
	case gooduser.FieldCoinType:
		return m.CoinType()
	case gooduser.FieldHashRate:
		return m.HashRate()
	case gooduser.FieldReadPageLink:
		return m.ReadPageLink()
	case gooduser.FieldRevenueType:
		return m.RevenueType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gooduser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case gooduser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case gooduser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case gooduser.FieldEntID:
		return m.OldEntID(ctx)
	case gooduser.FieldRootUserID:
		return m.OldRootUserID(ctx)
	case gooduser.FieldName:
		return m.OldName(ctx)
	case gooduser.FieldMiningpoolType:
		return m.OldMiningpoolType(ctx)
	case gooduser.FieldCoinType:
		return m.OldCoinType(ctx)
	case gooduser.FieldHashRate:
		return m.OldHashRate(ctx)
	case gooduser.FieldReadPageLink:
		return m.OldReadPageLink(ctx)
	case gooduser.FieldRevenueType:
		return m.OldRevenueType(ctx)
	}
	return nil, fmt.Errorf("unknown GoodUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gooduser.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case gooduser.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case gooduser.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case gooduser.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case gooduser.FieldRootUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootUserID(v)
		return nil
	case gooduser.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case gooduser.FieldMiningpoolType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiningpoolType(v)
		return nil
	case gooduser.FieldCoinType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinType(v)
		return nil
	case gooduser.FieldHashRate:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashRate(v)
		return nil
	case gooduser.FieldReadPageLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadPageLink(v)
		return nil
	case gooduser.FieldRevenueType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevenueType(v)
		return nil
	}
	return fmt.Errorf("unknown GoodUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, gooduser.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, gooduser.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, gooduser.FieldDeletedAt)
	}
	if m.addhash_rate != nil {
		fields = append(fields, gooduser.FieldHashRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case gooduser.FieldCreatedAt:
		return m.AddedCreatedAt()
	case gooduser.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case gooduser.FieldDeletedAt:
		return m.AddedDeletedAt()
	case gooduser.FieldHashRate:
		return m.AddedHashRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case gooduser.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case gooduser.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case gooduser.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case gooduser.FieldHashRate:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHashRate(v)
		return nil
	}
	return fmt.Errorf("unknown GoodUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(gooduser.FieldHashRate) {
		fields = append(fields, gooduser.FieldHashRate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodUserMutation) ClearField(name string) error {
	switch name {
	case gooduser.FieldHashRate:
		m.ClearHashRate()
		return nil
	}
	return fmt.Errorf("unknown GoodUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodUserMutation) ResetField(name string) error {
	switch name {
	case gooduser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case gooduser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case gooduser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case gooduser.FieldEntID:
		m.ResetEntID()
		return nil
	case gooduser.FieldRootUserID:
		m.ResetRootUserID()
		return nil
	case gooduser.FieldName:
		m.ResetName()
		return nil
	case gooduser.FieldMiningpoolType:
		m.ResetMiningpoolType()
		return nil
	case gooduser.FieldCoinType:
		m.ResetCoinType()
		return nil
	case gooduser.FieldHashRate:
		m.ResetHashRate()
		return nil
	case gooduser.FieldReadPageLink:
		m.ResetReadPageLink()
		return nil
	case gooduser.FieldRevenueType:
		m.ResetRevenueType()
		return nil
	}
	return fmt.Errorf("unknown GoodUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodUser edge %s", name)
}

// OrderUserMutation represents an operation that mutates the OrderUser nodes in the graph.
type OrderUserMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	ent_id          *uuid.UUID
	root_user_id    *uuid.UUID
	good_user_id    *uuid.UUID
	user_id         *uuid.UUID
	app_id          *uuid.UUID
	name            *string
	miningpool_type *string
	coin_type       *string
	proportion      *float32
	addproportion   *float32
	revenue_address *string
	read_page_link  *string
	auto_pay        *bool
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*OrderUser, error)
	predicates      []predicate.OrderUser
}

var _ ent.Mutation = (*OrderUserMutation)(nil)

// orderuserOption allows management of the mutation configuration using functional options.
type orderuserOption func(*OrderUserMutation)

// newOrderUserMutation creates new mutation for the OrderUser entity.
func newOrderUserMutation(c config, op Op, opts ...orderuserOption) *OrderUserMutation {
	m := &OrderUserMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderUserID sets the ID field of the mutation.
func withOrderUserID(id uint32) orderuserOption {
	return func(m *OrderUserMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderUser
		)
		m.oldValue = func(ctx context.Context) (*OrderUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderUser sets the old OrderUser of the mutation.
func withOrderUser(node *OrderUser) orderuserOption {
	return func(m *OrderUserMutation) {
		m.oldValue = func(context.Context) (*OrderUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderUser entities.
func (m *OrderUserMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderUserMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderUserMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderUserMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderUserMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderUser entity.
// If the OrderUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderUserMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *OrderUserMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *OrderUserMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderUserMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderUserMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderUserMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderUser entity.
// If the OrderUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderUserMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *OrderUserMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *OrderUserMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderUserMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderUserMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrderUser entity.
// If the OrderUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderUserMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *OrderUserMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *OrderUserMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *OrderUserMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *OrderUserMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the OrderUser entity.
// If the OrderUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderUserMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *OrderUserMutation) ResetEntID() {
	m.ent_id = nil
}

// SetRootUserID sets the "root_user_id" field.
func (m *OrderUserMutation) SetRootUserID(u uuid.UUID) {
	m.root_user_id = &u
}

// RootUserID returns the value of the "root_user_id" field in the mutation.
func (m *OrderUserMutation) RootUserID() (r uuid.UUID, exists bool) {
	v := m.root_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRootUserID returns the old "root_user_id" field's value of the OrderUser entity.
// If the OrderUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderUserMutation) OldRootUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootUserID: %w", err)
	}
	return oldValue.RootUserID, nil
}

// ResetRootUserID resets all changes to the "root_user_id" field.
func (m *OrderUserMutation) ResetRootUserID() {
	m.root_user_id = nil
}

// SetGoodUserID sets the "good_user_id" field.
func (m *OrderUserMutation) SetGoodUserID(u uuid.UUID) {
	m.good_user_id = &u
}

// GoodUserID returns the value of the "good_user_id" field in the mutation.
func (m *OrderUserMutation) GoodUserID() (r uuid.UUID, exists bool) {
	v := m.good_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodUserID returns the old "good_user_id" field's value of the OrderUser entity.
// If the OrderUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderUserMutation) OldGoodUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodUserID: %w", err)
	}
	return oldValue.GoodUserID, nil
}

// ResetGoodUserID resets all changes to the "good_user_id" field.
func (m *OrderUserMutation) ResetGoodUserID() {
	m.good_user_id = nil
}

// SetUserID sets the "user_id" field.
func (m *OrderUserMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrderUserMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrderUser entity.
// If the OrderUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderUserMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrderUserMutation) ResetUserID() {
	m.user_id = nil
}

// SetAppID sets the "app_id" field.
func (m *OrderUserMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *OrderUserMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the OrderUser entity.
// If the OrderUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderUserMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *OrderUserMutation) ResetAppID() {
	m.app_id = nil
}

// SetName sets the "name" field.
func (m *OrderUserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrderUserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrderUser entity.
// If the OrderUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderUserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrderUserMutation) ResetName() {
	m.name = nil
}

// SetMiningpoolType sets the "miningpool_type" field.
func (m *OrderUserMutation) SetMiningpoolType(s string) {
	m.miningpool_type = &s
}

// MiningpoolType returns the value of the "miningpool_type" field in the mutation.
func (m *OrderUserMutation) MiningpoolType() (r string, exists bool) {
	v := m.miningpool_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMiningpoolType returns the old "miningpool_type" field's value of the OrderUser entity.
// If the OrderUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderUserMutation) OldMiningpoolType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMiningpoolType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMiningpoolType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiningpoolType: %w", err)
	}
	return oldValue.MiningpoolType, nil
}

// ResetMiningpoolType resets all changes to the "miningpool_type" field.
func (m *OrderUserMutation) ResetMiningpoolType() {
	m.miningpool_type = nil
}

// SetCoinType sets the "coin_type" field.
func (m *OrderUserMutation) SetCoinType(s string) {
	m.coin_type = &s
}

// CoinType returns the value of the "coin_type" field in the mutation.
func (m *OrderUserMutation) CoinType() (r string, exists bool) {
	v := m.coin_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinType returns the old "coin_type" field's value of the OrderUser entity.
// If the OrderUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderUserMutation) OldCoinType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinType: %w", err)
	}
	return oldValue.CoinType, nil
}

// ResetCoinType resets all changes to the "coin_type" field.
func (m *OrderUserMutation) ResetCoinType() {
	m.coin_type = nil
}

// SetProportion sets the "proportion" field.
func (m *OrderUserMutation) SetProportion(f float32) {
	m.proportion = &f
	m.addproportion = nil
}

// Proportion returns the value of the "proportion" field in the mutation.
func (m *OrderUserMutation) Proportion() (r float32, exists bool) {
	v := m.proportion
	if v == nil {
		return
	}
	return *v, true
}

// OldProportion returns the old "proportion" field's value of the OrderUser entity.
// If the OrderUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderUserMutation) OldProportion(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProportion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProportion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProportion: %w", err)
	}
	return oldValue.Proportion, nil
}

// AddProportion adds f to the "proportion" field.
func (m *OrderUserMutation) AddProportion(f float32) {
	if m.addproportion != nil {
		*m.addproportion += f
	} else {
		m.addproportion = &f
	}
}

// AddedProportion returns the value that was added to the "proportion" field in this mutation.
func (m *OrderUserMutation) AddedProportion() (r float32, exists bool) {
	v := m.addproportion
	if v == nil {
		return
	}
	return *v, true
}

// ClearProportion clears the value of the "proportion" field.
func (m *OrderUserMutation) ClearProportion() {
	m.proportion = nil
	m.addproportion = nil
	m.clearedFields[orderuser.FieldProportion] = struct{}{}
}

// ProportionCleared returns if the "proportion" field was cleared in this mutation.
func (m *OrderUserMutation) ProportionCleared() bool {
	_, ok := m.clearedFields[orderuser.FieldProportion]
	return ok
}

// ResetProportion resets all changes to the "proportion" field.
func (m *OrderUserMutation) ResetProportion() {
	m.proportion = nil
	m.addproportion = nil
	delete(m.clearedFields, orderuser.FieldProportion)
}

// SetRevenueAddress sets the "revenue_address" field.
func (m *OrderUserMutation) SetRevenueAddress(s string) {
	m.revenue_address = &s
}

// RevenueAddress returns the value of the "revenue_address" field in the mutation.
func (m *OrderUserMutation) RevenueAddress() (r string, exists bool) {
	v := m.revenue_address
	if v == nil {
		return
	}
	return *v, true
}

// OldRevenueAddress returns the old "revenue_address" field's value of the OrderUser entity.
// If the OrderUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderUserMutation) OldRevenueAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevenueAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevenueAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevenueAddress: %w", err)
	}
	return oldValue.RevenueAddress, nil
}

// ClearRevenueAddress clears the value of the "revenue_address" field.
func (m *OrderUserMutation) ClearRevenueAddress() {
	m.revenue_address = nil
	m.clearedFields[orderuser.FieldRevenueAddress] = struct{}{}
}

// RevenueAddressCleared returns if the "revenue_address" field was cleared in this mutation.
func (m *OrderUserMutation) RevenueAddressCleared() bool {
	_, ok := m.clearedFields[orderuser.FieldRevenueAddress]
	return ok
}

// ResetRevenueAddress resets all changes to the "revenue_address" field.
func (m *OrderUserMutation) ResetRevenueAddress() {
	m.revenue_address = nil
	delete(m.clearedFields, orderuser.FieldRevenueAddress)
}

// SetReadPageLink sets the "read_page_link" field.
func (m *OrderUserMutation) SetReadPageLink(s string) {
	m.read_page_link = &s
}

// ReadPageLink returns the value of the "read_page_link" field in the mutation.
func (m *OrderUserMutation) ReadPageLink() (r string, exists bool) {
	v := m.read_page_link
	if v == nil {
		return
	}
	return *v, true
}

// OldReadPageLink returns the old "read_page_link" field's value of the OrderUser entity.
// If the OrderUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderUserMutation) OldReadPageLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadPageLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadPageLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadPageLink: %w", err)
	}
	return oldValue.ReadPageLink, nil
}

// ResetReadPageLink resets all changes to the "read_page_link" field.
func (m *OrderUserMutation) ResetReadPageLink() {
	m.read_page_link = nil
}

// SetAutoPay sets the "auto_pay" field.
func (m *OrderUserMutation) SetAutoPay(b bool) {
	m.auto_pay = &b
}

// AutoPay returns the value of the "auto_pay" field in the mutation.
func (m *OrderUserMutation) AutoPay() (r bool, exists bool) {
	v := m.auto_pay
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoPay returns the old "auto_pay" field's value of the OrderUser entity.
// If the OrderUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderUserMutation) OldAutoPay(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoPay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoPay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoPay: %w", err)
	}
	return oldValue.AutoPay, nil
}

// ClearAutoPay clears the value of the "auto_pay" field.
func (m *OrderUserMutation) ClearAutoPay() {
	m.auto_pay = nil
	m.clearedFields[orderuser.FieldAutoPay] = struct{}{}
}

// AutoPayCleared returns if the "auto_pay" field was cleared in this mutation.
func (m *OrderUserMutation) AutoPayCleared() bool {
	_, ok := m.clearedFields[orderuser.FieldAutoPay]
	return ok
}

// ResetAutoPay resets all changes to the "auto_pay" field.
func (m *OrderUserMutation) ResetAutoPay() {
	m.auto_pay = nil
	delete(m.clearedFields, orderuser.FieldAutoPay)
}

// Where appends a list predicates to the OrderUserMutation builder.
func (m *OrderUserMutation) Where(ps ...predicate.OrderUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderUser).
func (m *OrderUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderUserMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, orderuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, orderuser.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, orderuser.FieldEntID)
	}
	if m.root_user_id != nil {
		fields = append(fields, orderuser.FieldRootUserID)
	}
	if m.good_user_id != nil {
		fields = append(fields, orderuser.FieldGoodUserID)
	}
	if m.user_id != nil {
		fields = append(fields, orderuser.FieldUserID)
	}
	if m.app_id != nil {
		fields = append(fields, orderuser.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, orderuser.FieldName)
	}
	if m.miningpool_type != nil {
		fields = append(fields, orderuser.FieldMiningpoolType)
	}
	if m.coin_type != nil {
		fields = append(fields, orderuser.FieldCoinType)
	}
	if m.proportion != nil {
		fields = append(fields, orderuser.FieldProportion)
	}
	if m.revenue_address != nil {
		fields = append(fields, orderuser.FieldRevenueAddress)
	}
	if m.read_page_link != nil {
		fields = append(fields, orderuser.FieldReadPageLink)
	}
	if m.auto_pay != nil {
		fields = append(fields, orderuser.FieldAutoPay)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderuser.FieldCreatedAt:
		return m.CreatedAt()
	case orderuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderuser.FieldDeletedAt:
		return m.DeletedAt()
	case orderuser.FieldEntID:
		return m.EntID()
	case orderuser.FieldRootUserID:
		return m.RootUserID()
	case orderuser.FieldGoodUserID:
		return m.GoodUserID()
	case orderuser.FieldUserID:
		return m.UserID()
	case orderuser.FieldAppID:
		return m.AppID()
	case orderuser.FieldName:
		return m.Name()
	case orderuser.FieldMiningpoolType:
		return m.MiningpoolType()
	case orderuser.FieldCoinType:
		return m.CoinType()
	case orderuser.FieldProportion:
		return m.Proportion()
	case orderuser.FieldRevenueAddress:
		return m.RevenueAddress()
	case orderuser.FieldReadPageLink:
		return m.ReadPageLink()
	case orderuser.FieldAutoPay:
		return m.AutoPay()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orderuser.FieldEntID:
		return m.OldEntID(ctx)
	case orderuser.FieldRootUserID:
		return m.OldRootUserID(ctx)
	case orderuser.FieldGoodUserID:
		return m.OldGoodUserID(ctx)
	case orderuser.FieldUserID:
		return m.OldUserID(ctx)
	case orderuser.FieldAppID:
		return m.OldAppID(ctx)
	case orderuser.FieldName:
		return m.OldName(ctx)
	case orderuser.FieldMiningpoolType:
		return m.OldMiningpoolType(ctx)
	case orderuser.FieldCoinType:
		return m.OldCoinType(ctx)
	case orderuser.FieldProportion:
		return m.OldProportion(ctx)
	case orderuser.FieldRevenueAddress:
		return m.OldRevenueAddress(ctx)
	case orderuser.FieldReadPageLink:
		return m.OldReadPageLink(ctx)
	case orderuser.FieldAutoPay:
		return m.OldAutoPay(ctx)
	}
	return nil, fmt.Errorf("unknown OrderUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderuser.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderuser.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderuser.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orderuser.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case orderuser.FieldRootUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootUserID(v)
		return nil
	case orderuser.FieldGoodUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodUserID(v)
		return nil
	case orderuser.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case orderuser.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case orderuser.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case orderuser.FieldMiningpoolType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiningpoolType(v)
		return nil
	case orderuser.FieldCoinType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinType(v)
		return nil
	case orderuser.FieldProportion:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProportion(v)
		return nil
	case orderuser.FieldRevenueAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevenueAddress(v)
		return nil
	case orderuser.FieldReadPageLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadPageLink(v)
		return nil
	case orderuser.FieldAutoPay:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoPay(v)
		return nil
	}
	return fmt.Errorf("unknown OrderUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, orderuser.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, orderuser.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, orderuser.FieldDeletedAt)
	}
	if m.addproportion != nil {
		fields = append(fields, orderuser.FieldProportion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderuser.FieldCreatedAt:
		return m.AddedCreatedAt()
	case orderuser.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case orderuser.FieldDeletedAt:
		return m.AddedDeletedAt()
	case orderuser.FieldProportion:
		return m.AddedProportion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderuser.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case orderuser.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case orderuser.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case orderuser.FieldProportion:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProportion(v)
		return nil
	}
	return fmt.Errorf("unknown OrderUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderuser.FieldProportion) {
		fields = append(fields, orderuser.FieldProportion)
	}
	if m.FieldCleared(orderuser.FieldRevenueAddress) {
		fields = append(fields, orderuser.FieldRevenueAddress)
	}
	if m.FieldCleared(orderuser.FieldAutoPay) {
		fields = append(fields, orderuser.FieldAutoPay)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderUserMutation) ClearField(name string) error {
	switch name {
	case orderuser.FieldProportion:
		m.ClearProportion()
		return nil
	case orderuser.FieldRevenueAddress:
		m.ClearRevenueAddress()
		return nil
	case orderuser.FieldAutoPay:
		m.ClearAutoPay()
		return nil
	}
	return fmt.Errorf("unknown OrderUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderUserMutation) ResetField(name string) error {
	switch name {
	case orderuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orderuser.FieldEntID:
		m.ResetEntID()
		return nil
	case orderuser.FieldRootUserID:
		m.ResetRootUserID()
		return nil
	case orderuser.FieldGoodUserID:
		m.ResetGoodUserID()
		return nil
	case orderuser.FieldUserID:
		m.ResetUserID()
		return nil
	case orderuser.FieldAppID:
		m.ResetAppID()
		return nil
	case orderuser.FieldName:
		m.ResetName()
		return nil
	case orderuser.FieldMiningpoolType:
		m.ResetMiningpoolType()
		return nil
	case orderuser.FieldCoinType:
		m.ResetCoinType()
		return nil
	case orderuser.FieldProportion:
		m.ResetProportion()
		return nil
	case orderuser.FieldRevenueAddress:
		m.ResetRevenueAddress()
		return nil
	case orderuser.FieldReadPageLink:
		m.ResetReadPageLink()
		return nil
	case orderuser.FieldAutoPay:
		m.ResetAutoPay()
		return nil
	}
	return fmt.Errorf("unknown OrderUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrderUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrderUser edge %s", name)
}

// PoolMutation represents an operation that mutates the Pool nodes in the graph.
type PoolMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	ent_id          *uuid.UUID
	miningpool_type *string
	name            *string
	site            *string
	description     *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Pool, error)
	predicates      []predicate.Pool
}

var _ ent.Mutation = (*PoolMutation)(nil)

// poolOption allows management of the mutation configuration using functional options.
type poolOption func(*PoolMutation)

// newPoolMutation creates new mutation for the Pool entity.
func newPoolMutation(c config, op Op, opts ...poolOption) *PoolMutation {
	m := &PoolMutation{
		config:        c,
		op:            op,
		typ:           TypePool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPoolID sets the ID field of the mutation.
func withPoolID(id uint32) poolOption {
	return func(m *PoolMutation) {
		var (
			err   error
			once  sync.Once
			value *Pool
		)
		m.oldValue = func(ctx context.Context) (*Pool, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pool.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPool sets the old Pool of the mutation.
func withPool(node *Pool) poolOption {
	return func(m *PoolMutation) {
		m.oldValue = func(context.Context) (*Pool, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PoolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PoolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Pool entities.
func (m *PoolMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PoolMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PoolMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Pool.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PoolMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PoolMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *PoolMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *PoolMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PoolMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PoolMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PoolMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *PoolMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *PoolMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PoolMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PoolMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PoolMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *PoolMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *PoolMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PoolMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *PoolMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *PoolMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *PoolMutation) ResetEntID() {
	m.ent_id = nil
}

// SetMiningpoolType sets the "miningpool_type" field.
func (m *PoolMutation) SetMiningpoolType(s string) {
	m.miningpool_type = &s
}

// MiningpoolType returns the value of the "miningpool_type" field in the mutation.
func (m *PoolMutation) MiningpoolType() (r string, exists bool) {
	v := m.miningpool_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMiningpoolType returns the old "miningpool_type" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldMiningpoolType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMiningpoolType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMiningpoolType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiningpoolType: %w", err)
	}
	return oldValue.MiningpoolType, nil
}

// ResetMiningpoolType resets all changes to the "miningpool_type" field.
func (m *PoolMutation) ResetMiningpoolType() {
	m.miningpool_type = nil
}

// SetName sets the "name" field.
func (m *PoolMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PoolMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PoolMutation) ResetName() {
	m.name = nil
}

// SetSite sets the "site" field.
func (m *PoolMutation) SetSite(s string) {
	m.site = &s
}

// Site returns the value of the "site" field in the mutation.
func (m *PoolMutation) Site() (r string, exists bool) {
	v := m.site
	if v == nil {
		return
	}
	return *v, true
}

// OldSite returns the old "site" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldSite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSite: %w", err)
	}
	return oldValue.Site, nil
}

// ClearSite clears the value of the "site" field.
func (m *PoolMutation) ClearSite() {
	m.site = nil
	m.clearedFields[pool.FieldSite] = struct{}{}
}

// SiteCleared returns if the "site" field was cleared in this mutation.
func (m *PoolMutation) SiteCleared() bool {
	_, ok := m.clearedFields[pool.FieldSite]
	return ok
}

// ResetSite resets all changes to the "site" field.
func (m *PoolMutation) ResetSite() {
	m.site = nil
	delete(m.clearedFields, pool.FieldSite)
}

// SetDescription sets the "description" field.
func (m *PoolMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PoolMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PoolMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[pool.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PoolMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[pool.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PoolMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, pool.FieldDescription)
}

// Where appends a list predicates to the PoolMutation builder.
func (m *PoolMutation) Where(ps ...predicate.Pool) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PoolMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Pool).
func (m *PoolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PoolMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, pool.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pool.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, pool.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, pool.FieldEntID)
	}
	if m.miningpool_type != nil {
		fields = append(fields, pool.FieldMiningpoolType)
	}
	if m.name != nil {
		fields = append(fields, pool.FieldName)
	}
	if m.site != nil {
		fields = append(fields, pool.FieldSite)
	}
	if m.description != nil {
		fields = append(fields, pool.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PoolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pool.FieldCreatedAt:
		return m.CreatedAt()
	case pool.FieldUpdatedAt:
		return m.UpdatedAt()
	case pool.FieldDeletedAt:
		return m.DeletedAt()
	case pool.FieldEntID:
		return m.EntID()
	case pool.FieldMiningpoolType:
		return m.MiningpoolType()
	case pool.FieldName:
		return m.Name()
	case pool.FieldSite:
		return m.Site()
	case pool.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PoolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pool.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pool.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pool.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case pool.FieldEntID:
		return m.OldEntID(ctx)
	case pool.FieldMiningpoolType:
		return m.OldMiningpoolType(ctx)
	case pool.FieldName:
		return m.OldName(ctx)
	case pool.FieldSite:
		return m.OldSite(ctx)
	case pool.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Pool field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PoolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pool.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pool.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pool.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case pool.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case pool.FieldMiningpoolType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiningpoolType(v)
		return nil
	case pool.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case pool.FieldSite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSite(v)
		return nil
	case pool.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Pool field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PoolMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, pool.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, pool.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, pool.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PoolMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pool.FieldCreatedAt:
		return m.AddedCreatedAt()
	case pool.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case pool.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PoolMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pool.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case pool.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case pool.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Pool numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PoolMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pool.FieldSite) {
		fields = append(fields, pool.FieldSite)
	}
	if m.FieldCleared(pool.FieldDescription) {
		fields = append(fields, pool.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PoolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PoolMutation) ClearField(name string) error {
	switch name {
	case pool.FieldSite:
		m.ClearSite()
		return nil
	case pool.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Pool nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PoolMutation) ResetField(name string) error {
	switch name {
	case pool.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pool.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pool.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case pool.FieldEntID:
		m.ResetEntID()
		return nil
	case pool.FieldMiningpoolType:
		m.ResetMiningpoolType()
		return nil
	case pool.FieldName:
		m.ResetName()
		return nil
	case pool.FieldSite:
		m.ResetSite()
		return nil
	case pool.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Pool field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PoolMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PoolMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PoolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PoolMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PoolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PoolMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PoolMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Pool unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PoolMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Pool edge %s", name)
}

// RootUserMutation represents an operation that mutates the RootUser nodes in the graph.
type RootUserMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	created_at      *uint32
	addcreated_at   *int32
	updated_at      *uint32
	addupdated_at   *int32
	deleted_at      *uint32
	adddeleted_at   *int32
	ent_id          *uuid.UUID
	name            *string
	miningpool_type *string
	email           *string
	auth_token      *string
	authed          *bool
	remark          *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*RootUser, error)
	predicates      []predicate.RootUser
}

var _ ent.Mutation = (*RootUserMutation)(nil)

// rootuserOption allows management of the mutation configuration using functional options.
type rootuserOption func(*RootUserMutation)

// newRootUserMutation creates new mutation for the RootUser entity.
func newRootUserMutation(c config, op Op, opts ...rootuserOption) *RootUserMutation {
	m := &RootUserMutation{
		config:        c,
		op:            op,
		typ:           TypeRootUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRootUserID sets the ID field of the mutation.
func withRootUserID(id uint32) rootuserOption {
	return func(m *RootUserMutation) {
		var (
			err   error
			once  sync.Once
			value *RootUser
		)
		m.oldValue = func(ctx context.Context) (*RootUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RootUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRootUser sets the old RootUser of the mutation.
func withRootUser(node *RootUser) rootuserOption {
	return func(m *RootUserMutation) {
		m.oldValue = func(context.Context) (*RootUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RootUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RootUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RootUser entities.
func (m *RootUserMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RootUserMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RootUserMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RootUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RootUserMutation) SetCreatedAt(u uint32) {
	m.created_at = &u
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RootUserMutation) CreatedAt() (r uint32, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RootUser entity.
// If the RootUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootUserMutation) OldCreatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds u to the "created_at" field.
func (m *RootUserMutation) AddCreatedAt(u int32) {
	if m.addcreated_at != nil {
		*m.addcreated_at += u
	} else {
		m.addcreated_at = &u
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RootUserMutation) AddedCreatedAt() (r int32, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RootUserMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RootUserMutation) SetUpdatedAt(u uint32) {
	m.updated_at = &u
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RootUserMutation) UpdatedAt() (r uint32, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RootUser entity.
// If the RootUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootUserMutation) OldUpdatedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds u to the "updated_at" field.
func (m *RootUserMutation) AddUpdatedAt(u int32) {
	if m.addupdated_at != nil {
		*m.addupdated_at += u
	} else {
		m.addupdated_at = &u
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *RootUserMutation) AddedUpdatedAt() (r int32, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RootUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RootUserMutation) SetDeletedAt(u uint32) {
	m.deleted_at = &u
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RootUserMutation) DeletedAt() (r uint32, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RootUser entity.
// If the RootUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootUserMutation) OldDeletedAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds u to the "deleted_at" field.
func (m *RootUserMutation) AddDeletedAt(u int32) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += u
	} else {
		m.adddeleted_at = &u
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RootUserMutation) AddedDeletedAt() (r int32, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RootUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEntID sets the "ent_id" field.
func (m *RootUserMutation) SetEntID(u uuid.UUID) {
	m.ent_id = &u
}

// EntID returns the value of the "ent_id" field in the mutation.
func (m *RootUserMutation) EntID() (r uuid.UUID, exists bool) {
	v := m.ent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntID returns the old "ent_id" field's value of the RootUser entity.
// If the RootUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootUserMutation) OldEntID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntID: %w", err)
	}
	return oldValue.EntID, nil
}

// ResetEntID resets all changes to the "ent_id" field.
func (m *RootUserMutation) ResetEntID() {
	m.ent_id = nil
}

// SetName sets the "name" field.
func (m *RootUserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RootUserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RootUser entity.
// If the RootUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootUserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RootUserMutation) ResetName() {
	m.name = nil
}

// SetMiningpoolType sets the "miningpool_type" field.
func (m *RootUserMutation) SetMiningpoolType(s string) {
	m.miningpool_type = &s
}

// MiningpoolType returns the value of the "miningpool_type" field in the mutation.
func (m *RootUserMutation) MiningpoolType() (r string, exists bool) {
	v := m.miningpool_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMiningpoolType returns the old "miningpool_type" field's value of the RootUser entity.
// If the RootUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootUserMutation) OldMiningpoolType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMiningpoolType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMiningpoolType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMiningpoolType: %w", err)
	}
	return oldValue.MiningpoolType, nil
}

// ResetMiningpoolType resets all changes to the "miningpool_type" field.
func (m *RootUserMutation) ResetMiningpoolType() {
	m.miningpool_type = nil
}

// SetEmail sets the "email" field.
func (m *RootUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *RootUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the RootUser entity.
// If the RootUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *RootUserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[rootuser.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *RootUserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[rootuser.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *RootUserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, rootuser.FieldEmail)
}

// SetAuthToken sets the "auth_token" field.
func (m *RootUserMutation) SetAuthToken(s string) {
	m.auth_token = &s
}

// AuthToken returns the value of the "auth_token" field in the mutation.
func (m *RootUserMutation) AuthToken() (r string, exists bool) {
	v := m.auth_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthToken returns the old "auth_token" field's value of the RootUser entity.
// If the RootUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootUserMutation) OldAuthToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthToken: %w", err)
	}
	return oldValue.AuthToken, nil
}

// ResetAuthToken resets all changes to the "auth_token" field.
func (m *RootUserMutation) ResetAuthToken() {
	m.auth_token = nil
}

// SetAuthed sets the "authed" field.
func (m *RootUserMutation) SetAuthed(b bool) {
	m.authed = &b
}

// Authed returns the value of the "authed" field in the mutation.
func (m *RootUserMutation) Authed() (r bool, exists bool) {
	v := m.authed
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthed returns the old "authed" field's value of the RootUser entity.
// If the RootUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootUserMutation) OldAuthed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthed: %w", err)
	}
	return oldValue.Authed, nil
}

// ResetAuthed resets all changes to the "authed" field.
func (m *RootUserMutation) ResetAuthed() {
	m.authed = nil
}

// SetRemark sets the "remark" field.
func (m *RootUserMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *RootUserMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the RootUser entity.
// If the RootUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RootUserMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *RootUserMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[rootuser.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *RootUserMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[rootuser.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *RootUserMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, rootuser.FieldRemark)
}

// Where appends a list predicates to the RootUserMutation builder.
func (m *RootUserMutation) Where(ps ...predicate.RootUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RootUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RootUser).
func (m *RootUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RootUserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, rootuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rootuser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, rootuser.FieldDeletedAt)
	}
	if m.ent_id != nil {
		fields = append(fields, rootuser.FieldEntID)
	}
	if m.name != nil {
		fields = append(fields, rootuser.FieldName)
	}
	if m.miningpool_type != nil {
		fields = append(fields, rootuser.FieldMiningpoolType)
	}
	if m.email != nil {
		fields = append(fields, rootuser.FieldEmail)
	}
	if m.auth_token != nil {
		fields = append(fields, rootuser.FieldAuthToken)
	}
	if m.authed != nil {
		fields = append(fields, rootuser.FieldAuthed)
	}
	if m.remark != nil {
		fields = append(fields, rootuser.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RootUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rootuser.FieldCreatedAt:
		return m.CreatedAt()
	case rootuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case rootuser.FieldDeletedAt:
		return m.DeletedAt()
	case rootuser.FieldEntID:
		return m.EntID()
	case rootuser.FieldName:
		return m.Name()
	case rootuser.FieldMiningpoolType:
		return m.MiningpoolType()
	case rootuser.FieldEmail:
		return m.Email()
	case rootuser.FieldAuthToken:
		return m.AuthToken()
	case rootuser.FieldAuthed:
		return m.Authed()
	case rootuser.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RootUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rootuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rootuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rootuser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case rootuser.FieldEntID:
		return m.OldEntID(ctx)
	case rootuser.FieldName:
		return m.OldName(ctx)
	case rootuser.FieldMiningpoolType:
		return m.OldMiningpoolType(ctx)
	case rootuser.FieldEmail:
		return m.OldEmail(ctx)
	case rootuser.FieldAuthToken:
		return m.OldAuthToken(ctx)
	case rootuser.FieldAuthed:
		return m.OldAuthed(ctx)
	case rootuser.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown RootUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RootUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rootuser.FieldCreatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rootuser.FieldUpdatedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rootuser.FieldDeletedAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case rootuser.FieldEntID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntID(v)
		return nil
	case rootuser.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case rootuser.FieldMiningpoolType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMiningpoolType(v)
		return nil
	case rootuser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case rootuser.FieldAuthToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthToken(v)
		return nil
	case rootuser.FieldAuthed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthed(v)
		return nil
	case rootuser.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown RootUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RootUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, rootuser.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, rootuser.FieldUpdatedAt)
	}
	if m.adddeleted_at != nil {
		fields = append(fields, rootuser.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RootUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rootuser.FieldCreatedAt:
		return m.AddedCreatedAt()
	case rootuser.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case rootuser.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RootUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rootuser.FieldCreatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case rootuser.FieldUpdatedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case rootuser.FieldDeletedAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RootUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RootUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rootuser.FieldEmail) {
		fields = append(fields, rootuser.FieldEmail)
	}
	if m.FieldCleared(rootuser.FieldRemark) {
		fields = append(fields, rootuser.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RootUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RootUserMutation) ClearField(name string) error {
	switch name {
	case rootuser.FieldEmail:
		m.ClearEmail()
		return nil
	case rootuser.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown RootUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RootUserMutation) ResetField(name string) error {
	switch name {
	case rootuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rootuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rootuser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case rootuser.FieldEntID:
		m.ResetEntID()
		return nil
	case rootuser.FieldName:
		m.ResetName()
		return nil
	case rootuser.FieldMiningpoolType:
		m.ResetMiningpoolType()
		return nil
	case rootuser.FieldEmail:
		m.ResetEmail()
		return nil
	case rootuser.FieldAuthToken:
		m.ResetAuthToken()
		return nil
	case rootuser.FieldAuthed:
		m.ResetAuthed()
		return nil
	case rootuser.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown RootUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RootUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RootUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RootUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RootUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RootUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RootUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RootUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RootUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RootUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RootUser edge %s", name)
}
